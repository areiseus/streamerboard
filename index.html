<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ ì•¤ì•„ì´ë§¤ë°©ë‘ ì •ë°€ ê·¸ë¦¬ë“œ í˜„í™©íŒ</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* [ê¸°ë³¸ ìŠ¤íƒ€ì¼] */
        body { margin: 0; background: #f4f6f8; font-family: 'Pretendard', sans-serif; overflow-x: hidden; height: 100vh; }
        .container { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; }

        .admin-link { position: fixed; top: 20px; right: 20px; font-size: 1.5rem; text-decoration: none; opacity: 0.3; z-index: 2000; transition: 0.3s; }
        .admin-link:hover { opacity: 1; transform: rotate(90deg); }

        /* [1. í—¤ë”] */
        header {
            flex: 0 0 auto; width: 100%; background: #fff; padding: 15px 0; text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); z-index: 100;
        }
        h1 { margin: 0 0 5px 0; font-size: 1.8rem; font-weight: 900; color: #333; }
        .refresh-btn {
            background: #333; color: #fff; border: none; padding: 6px 15px; border-radius: 4px;
            font-size: 0.85rem; font-weight: bold; cursor: pointer;
        }
        .refresh-btn:hover { background: #555; }

        /* [2. ë©”ì¸ ì˜ì—­] */
        #main-area {
            flex: 1; width: 100%; position: relative; overflow-y: auto; overflow-x: hidden;
            background: radial-gradient(circle at 50% 50%, #ffffff 0%, #e9ecef 100%);
            display: flex; justify-content: center; /* ê·¸ë¦¬ë“œ ì¤‘ì•™ ì •ë ¬ìš© */
        }

        /* ì»¨í…ì¸  ë˜í¼ (SVGì™€ ì¹´ë“œê°€ ë“¤ì–´ê°ˆ ì‹¤ì œ ê³µê°„) */
        #content-wrapper {
            position: relative;
            width: 600px; /* 5ì—´ * 110px + ì—¬ìœ  -> ê³ ì •í­ */
            min-height: 1000px;
            margin-top: 50px;
            margin-bottom: 50px;
        }

        svg { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none; }
        #card-overlay { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 2; }

        /* [3. í•˜ë‹¨ ì˜ì—­] */
        #footer-area {
            flex: 0 0 auto; width: 90%; max-width: 1000px;
            background: #fff; border-top: 1px solid #ddd;
            padding: 20px; margin-bottom: 20px; border-radius: 10px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05); z-index: 10;
        }
        .footer-header { font-weight: bold; color: #555; margin-bottom: 10px; border-bottom: 2px solid #eee; padding-bottom: 5px; }
        .no-group-grid { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }

        /* [ì¹´ë“œ ë””ìì¸] */
        .card {
            position: absolute; 
            width: 100px; height: 130px;
            background: #fff; border-radius: 8px;
            border: 2px solid transparent;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            padding-top: 15px; box-sizing: border-box;
            cursor: pointer; transition: transform 0.2s;
        }
        .card:hover { transform: scale(1.1); z-index: 999; box-shadow: 0 8px 20px rgba(0,0,0,0.2); border-color: #aaa; }

        /* í•˜ë‹¨ ì¹´ë“œëŠ” relative */
        .no-group-grid .card { position: relative; left: auto !important; top: auto !important; }

        .profile-img { width: 65px; height: 65px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; margin-bottom: 8px; background: #f0f0f0; }
        .pf-badge {
            position: absolute; top: 65px; right: 15px; width: 18px; height: 18px; border-radius: 50%;
            color: #fff; font-size: 9px; font-weight: bold; display: flex; align-items: center; justify-content: center; border: 2px solid #fff;
        }
        .soop { background: #42C769; } .chzzk { background: #00E59D; color:#333; }
        .name-tag { font-size: 0.85rem; font-weight: bold; color: #333; width: 90px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .is-live { border-color: #ff4757 !important; background: #fff5f5; }
        .is-live .profile-img { border-color: #ff4757; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255,71,87,0.6); } 70% { box-shadow: 0 0 0 8px rgba(255,71,87,0); } 100% { box-shadow: 0 0 0 0 rgba(255,71,87,0); } }

        /* í’ì„  ìŠ¤íƒ€ì¼ */
        .group-hull { fill-opacity: 0.08; stroke-linejoin: round; stroke-linecap: round; mix-blend-mode: multiply; transition: d 0.3s; }
        .group-label { font-size: 13px; font-weight: 800; fill: #444; text-anchor: middle; text-shadow: 1px 1px 0 #fff; pointer-events: none; }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>ìœ ì•¤ì•„ì´ë§¤ë°©ë‘ ì •ë°€ ê·¸ë¦¬ë“œ</h1>
        <button class="refresh-btn" onclick="location.reload()">ğŸ”„ ë°°ì¹˜ ì¬ê³„ì‚°</button>
    </header>
    <a href="admin.html" class="admin-link">âš™ï¸</a>

    <div id="main-area">
        <div id="content-wrapper">
            <svg id="svg-layer"></svg>
            <div id="card-overlay"></div>
        </div>
    </div>

    <div id="footer-area" style="display:none;">
        <div class="footer-header">ğŸ“‚ ë¯¸ë¶„ë¥˜ ìŠ¤íŠ¸ë¦¬ë¨¸ (<span id="no-group-cnt">0</span>)</div>
        <div id="no-group-grid" class="no-group-grid"></div>
    </div>
</div>

<script>
    // [ì¡°ê±´ 0] ê·¸ë¦¬ë“œëŠ” ê°€ë¡œ 5ì¹¸ ê³ ì •
    const COLS = 5;
    const CELL_W = 110; 
    const CELL_H = 150; 

    async function init() {
        try {
            const res = await fetch('/api/get_list');
            const data = await res.json();
            if (!data || data.length === 0) return;

            // 1. ë°ì´í„° íŒŒì‹±
            // [ìš°ì„ ìˆœìœ„ Fallback] ID ì•ŒíŒŒë²³ìˆœ ì •ë ¬
            data.sort((a, b) => a.id.localeCompare(b.id));

            const groupedMembers = [];
            const noGroupMembers = [];

            // ê·¸ë£¹ ì •ë³´ íŒŒì‹± ë° ë¶„ë¥˜
            data.forEach(m => {
                m._groups = parseGroups(m);
                m.multiGroupCount = m._groups.length; // ê·¸ë£¹ ì†Œì† ê°œìˆ˜ (ì¡°ê±´ 8ìš©)
                
                if (m._groups.length > 0) groupedMembers.push(m);
                else noGroupMembers.push(m);
            });

            // 2. ë¯¸ë¶„ë¥˜ ë°°ì¹˜ (ì¡°ê±´ 22)
            renderFooter(noGroupMembers);

            // 3. ê·¸ë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰ (ì¡°ê±´ 1~21)
            if (groupedMembers.length > 0) {
                runGridAlgorithm(groupedMembers);
            }

            checkLive(data);

        } catch (e) { console.error(e); }
    }

    // =================================================================
    // [ì•Œê³ ë¦¬ì¦˜ ì—”ì§„] ì‚¬ìš©ìê°€ ì •ì˜í•œ 22ê°€ì§€ ê·œì¹™ ìˆ˜í–‰
    // =================================================================
    function runGridAlgorithm(members) {
        
        // 1. ê·¸ë£¹ ê°ì²´ ìƒì„±
        const groupMap = {}; // name -> { name, members: [], size }
        members.forEach(m => {
            m._groups.forEach(gName => {
                if(!groupMap[gName]) groupMap[gName] = { name: gName, members: [], score: 0 };
                groupMap[gName].members.push(m);
            });
        });
        
        // ê·¸ë£¹ ë¦¬ìŠ¤íŠ¸ ë³€í™˜
        let groups = Object.values(groupMap);
        
        // [ì¡°ê±´ 6, 7] ì¤‘ì•™ ê·¸ë£¹(A) ì„ ì •ì„ ìœ„í•œ ì ìˆ˜ ê³„ì‚°
        // ì ìˆ˜ = (ê·¸ë£¹ì›ë“¤ì´ ì†í•œ íƒ€ ê·¸ë£¹ì˜ ì´ ê°œìˆ˜)
        groups.forEach(g => {
            let crossScore = 0;
            g.members.forEach(m => {
                crossScore += (m.multiGroupCount - 1); // ë³¸ì¸ ê·¸ë£¹ ì œì™¸
            });
            g.score = crossScore;
            g.size = g.members.length;
        });

        // [ì •ë ¬ 1ì°¨] ê·¸ë£¹ ì ìˆ˜(Score) ë†’ì€ ìˆœ -> ì‚¬ì´ì¦ˆ í° ìˆœ
        groups.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            return b.size - a.size;
        });

        // ==========================================================
        // [ë°°ì¹˜ ë¡œì§] Deque(ì–‘ë°©í–¥ í) ë°©ì‹ ì‚¬ìš©
        // ì¤‘ì•™(A)ì„ ë¨¼ì € ë†“ê³ , ìœ„(B)/ì•„ë˜(C)ë¡œ í™•ì¥
        // ==========================================================
        
        // 1. King Group (A) ì„ ì • (ê°€ì¥ ì ìˆ˜ ë†’ì€ ê·¸ë£¹)
        const centerGroup = groups[0]; 
        const placedGroups = [centerGroup]; // ë°°ì¹˜ëœ ìˆœì„œ (ë°°ì—´ì˜ ì¤‘ê°„ì´ A)
        const placedSet = new Set([centerGroup.name]);

        // 2. ë‚˜ë¨¸ì§€ ê·¸ë£¹ ë°°ì¹˜ (ìœ„/ì•„ë˜ êµì°¨ ë°°ì¹˜)
        // Aì™€ ê°€ì¥ ê´€ë ¨ ê¹Šì€ ê·¸ë£¹ì„ ì°¾ì•„ì„œ ìœ„, ê·¸ ë‹¤ìŒ ì•„ë˜ ìˆœì„œë¡œ ë¶™ì„
        let upTarget = centerGroup;
        let downTarget = centerGroup;
        
        // ë‚¨ì€ ê·¸ë£¹ë“¤
        let remaining = groups.slice(1);

        while(remaining.length > 0) {
            // [ì¡°ê±´ 9, 15] ìœ„(Up)ì— ë¶™ì¼ ê·¸ë£¹ ì°¾ê¸° (Targetê³¼ êµì§‘í•©ì´ ê°€ì¥ ë§ì€ ê·¸ë£¹)
            let bestUp = findBestNeighbor(upTarget, remaining);
            if(bestUp) {
                placedGroups.unshift(bestUp); // ë°°ì—´ ì•ì— ì¶”ê°€ (ìœ„ìª½ ë°°ì¹˜)
                placedSet.add(bestUp.name);
                upTarget = bestUp; // ê¸°ì¤€ì  ì´ë™
                remaining = remaining.filter(g => g.name !== bestUp.name);
            }

            // [ì¡°ê±´ 10, 15] ì•„ë˜(Down)ì— ë¶™ì¼ ê·¸ë£¹ ì°¾ê¸°
            if(remaining.length > 0) {
                let bestDown = findBestNeighbor(downTarget, remaining);
                if(bestDown) {
                    placedGroups.push(bestDown); // ë°°ì—´ ë’¤ì— ì¶”ê°€ (ì•„ë˜ìª½ ë°°ì¹˜)
                    placedSet.add(bestDown.name);
                    downTarget = bestDown;
                    remaining = remaining.filter(g => g.name !== bestDown.name);
                }
            }
            
            // ì—°ê²°ê³ ë¦¬ê°€ ëŠê²¼ìœ¼ë©´ ê·¸ëƒ¥ ë‚¨ì€ ê²ƒ ì¤‘ í°ê±° ë¶™ì„
            if(!bestUp && !bestDown && remaining.length > 0) {
                 const next = remaining.shift();
                 placedGroups.push(next);
            }
        }

        // ==========================================================
        // [ë©¤ë²„ ì •ë ¬ ë¡œì§] Vertical Alignment (ì¡°ê±´ 8, 11, 12)
        // ==========================================================
        
        // 1. ì¤‘ì•™ ê·¸ë£¹(A) ë‚´ë¶€ ì •ë ¬
        // [ì¡°ê±´ 8] ë‹¤ì¤‘ ì†Œì†(multiGroupCount) ë§ì€ ìˆœ -> ìš°ì¸¡ ë°°ì¹˜
        centerGroup.members.sort((a, b) => {
            if(a.multiGroupCount !== b.multiGroupCount) return a.multiGroupCount - b.multiGroupCount; // ì˜¤ë¦„ì°¨ìˆœ (ë‚˜ì¤‘ì— ë’¤ì§‘ê±°ë‚˜ ì¸ë±ìŠ¤ ë§¤í•‘)
            return a.id.localeCompare(b.id);
        }); 
        // ìš°ì¸¡ ì •ë ¬ì„ ìœ„í•´: [1ê°œì†Œì†, 1ê°œì†Œì†, ..., 3ê°œì†Œì†, 4ê°œì†Œì†] ë°°ì—´
        // ê·¸ë¦¬ë“œì— ë„£ì„ ë• 5ì¹¸ ì¤‘ ë’¤ìª½ë¶€í„° ì±„ìš°ê±°ë‚˜, ê·¸ëƒ¥ ìˆœì„œëŒ€ë¡œ ë†“ê³  CSSë¡œ ì¡°ì •?
        // -> ì¡°ê±´ 8: "ì˜¤ë¥¸ìª½ ê°€ì¥ ëìœ¼ë¡œ ì´ë™". 
        // -> ë°°ì—´ì˜ ë’¤ìª½(ì¸ë±ìŠ¤ê°€ í° ìª½)ì— ë°°ì¹˜í•˜ë©´ ë¨. (ê·¸ë¦¬ë“œëŠ” 0,1,2,3,4 ìˆœ)

        // ê° ë©¤ë²„ì—ê²Œ 'í™•ì •ëœ ì—´(Column)' ì¸ë±ìŠ¤ ë¶€ì—¬
        // ì¤‘ì•™ ê·¸ë£¹ì€ ê½‰ ì±„ìš°ì§€ ì•Šê³  ìš°ì¸¡ ì •ë ¬ (ì˜ˆ: 3ëª…ì´ë©´ [2, 3, 4]ì—´ ì°¨ì§€)
        // ì•„ë‹ˆë©´ ê·¸ëƒ¥ 0ë²ˆë¶€í„° ì±„ìš°ë˜, ì •ë ¬ ìˆœì„œì— ë”°ë¦„.
        // **í•´ì„:** ê·¸ëƒ¥ 0~4ë²ˆ ì—´ì„ ì‚¬ìš©í•˜ë˜, ì¤‘ìš” ì¸ë¬¼(ë‹¤ì¤‘ì†Œì†)ì´ 4ë²ˆ ì—´ì— ê°€ê¹ê²Œ.
        
        // ì¤‘ì•™ ê·¸ë£¹ì˜ ê° ë©¤ë²„ê°€ ì–´ëŠ 'ì—´(Col)'ì— ìˆëŠ”ì§€ ê¸°ë¡ (Map)
        const memberColMap = new Map(); // memberID -> colIndex
        
        // ë°°ì¹˜ ì‹œë®¬ë ˆì´ì…˜ (ìœ„ì—ì„œ ì•„ë˜ë¡œ ìˆœì°¨ ë°°ì¹˜)
        // placedGroups ë°°ì—´ ìˆœì„œëŒ€ë¡œ í–‰ì„ ì°¨ì§€í•¨.
        
        let currentRow = 0;
        const layoutData = []; // { member, row, col }

        placedGroups.forEach((group, gIdx) => {
            const isCenter = (group === centerGroup);
            
            // ë©¤ë²„ ì •ë ¬ ìˆ˜í–‰
            if(isCenter) {
                // ì´ë¯¸ ì •ë ¬ë¨ (ì¡°ê±´ 8ì— ì˜í•´ ë‹¤ì¤‘ì†Œì†ìê°€ ë’¤ìª½=ìš°ì¸¡)
            } else {
                // [ì¡°ê±´ 12] ìœ„/ì•„ë˜ ê·¸ë£¹ì€, ì¸ì ‘í•œ ê·¸ë£¹(A)ì˜ ë©¤ë²„ ìœ„ì¹˜ì— ë§ì¶° ì •ë ¬
                // "ìì„ íš¨ê³¼": ë‚´ ê·¸ë£¹ì˜ ë©¤ë²„ Mì´, Aê·¸ë£¹ì˜ ë©¤ë²„ Nê³¼ ê°™ë‹¤ë©´, Nì˜ ì—´(Col)ë¡œ ì´ë™í•˜ë ¤ê³  í•¨.
                
                // ê¸°ì¤€ì´ ë˜ëŠ” ì´ì „/ë‹¤ìŒ ê·¸ë£¹ ì°¾ê¸°
                // ìœ„ìª½ ê·¸ë£¹ì€ ì•„ë˜ìª½ ê·¸ë£¹ì„ ë³´ê³  ì •ë ¬, ì•„ë˜ìª½ ê·¸ë£¹ì€ ìœ„ìª½ ê·¸ë£¹ì„ ë³´ê³  ì •ë ¬
                // ì—¬ê¸°ì„œëŠ” "ì¤‘ì•™ì—ì„œ í¼ì ¸ë‚˜ê°€ëŠ”" ìˆœì„œë¡œ ì •ë ¬í•´ì•¼ í•¨.
                // í•˜ì§€ë§Œ ë‹¨ìˆœí™”í•´ì„œ, ì´ë¯¸ ë°°ì¹˜ëœ ë©¤ë²„ë“¤ì˜ í‰ê·  Col ê°’ì„ ë”°ë¼ê°€ê²Œ í•¨.
                
                group.members.forEach(m => {
                    m.targetCol = -1;
                    // ì´ ë©¤ë²„ê°€ ì†í•œ ë‹¤ë¥¸ ê·¸ë£¹ë“¤ì´ ì–´ë””ì— ë°°ì¹˜ë˜ì—ˆëŠ”ì§€ í™•ì¸
                    m._groups.forEach(otherGName => {
                        if(otherGName === group.name) return;
                        // ë‹¤ë¥¸ ê·¸ë£¹ ë©¤ë²„ë“¤ ì¤‘ 'ë‚˜'ì¸ ì‚¬ëŒì˜ ìœ„ì¹˜ í™•ì¸
                        // (ë‹¨ìˆœí™”: ì´ë¯¸ ë°°ì¹˜ëœ ìœ„ì¹˜ê°’ ì°¸ì¡°)
                        if(memberColMap.has(m.id)) {
                            m.targetCol = memberColMap.get(m.id);
                        }
                    });
                });

                // TargetColì´ ìˆëŠ” ë©¤ë²„ë¥¼ ìš°ì„  ë°°ì¹˜, ì—†ìœ¼ë©´ ë¹ˆìë¦¬
                group.members.sort((a, b) => {
                    // íƒ€ê²Ÿ ì—´ì´ ìˆëŠ” ì‚¬ëŒì´ ìš°ì„  (í˜¹ì€ íƒ€ê²Ÿ ì—´ ìˆœì„œëŒ€ë¡œ)
                    if(a.targetCol !== -1 && b.targetCol !== -1) return a.targetCol - b.targetCol;
                    if(a.targetCol !== -1) return 1; // íƒ€ê²Ÿ ìˆëŠ” ì‚¬ëŒì´ ë’¤ë¡œ? (ì •ë ¬ ì „ëµì— ë”°ë¼ ë‹¤ë¦„)
                    if(b.targetCol !== -1) return -1;
                    return a.id.localeCompare(b.id);
                });
            }

            // ì‹¤ì œ ê·¸ë¦¬ë“œ ì¢Œí‘œ(Row, Col) í• ë‹¹
            // ê·¸ë£¹ì´ 5ëª…ì„ ë„˜ìœ¼ë©´ ë‹¤ìŒ ì¤„ë¡œ ë„˜ì–´ê° (Wrap)
            let localRow = 0;
            let localCol = 0;

            // [ì¡°ê±´ 8 ìƒì„¸êµ¬í˜„] ì¤‘ì•™ ê·¸ë£¹ì´ê³ , ì¸ì›ì´ 5ëª… ë¯¸ë§Œì´ë©´ 'ìš°ì¸¡ ì •ë ¬'
            let startCol = 0;
            if(isCenter && group.members.length < COLS) {
                 startCol = COLS - group.members.length; // ìš°ì¸¡ ë¶™ì´ê¸°
            }

            group.members.forEach((m, i) => {
                // ì¤„ë°”ê¿ˆ ì²˜ë¦¬
                if(startCol + i >= COLS) {
                    localRow++;
                    startCol = -i; // ë‹¤ìŒ ì¤„ì€ 0ë¶€í„°
                }
                
                let col = startCol + i;
                
                // ë§Œì•½ ìœ„ìª½ì—ì„œ ì •ë ¬ëœ 'targetCol'ì´ ìˆë‹¤ë©´ ìµœëŒ€í•œ ê·¸ ì—´ì— ë§ì¶¤ (Swap)
                // (ì´ ë¶€ë¶„ì€ ì™„ì „í•œ ìµœì í™”ê°€ ì–´ë µìœ¼ë¯€ë¡œ, ìœ„ìª½ sortë¡œ ëŒ€ì²´ë¨)

                let row = currentRow + localRow;
                
                layoutData.push({
                    member: m,
                    row: row,
                    col: col,
                    groupName: group.name
                });

                // ìœ„ì¹˜ ê¸°ë¡ (ë‹¤ìŒ ê·¸ë£¹ ì •ë ¬ìš©)
                memberColMap.set(m.id, col);
            });

            // ë‹¤ìŒ ê·¸ë£¹ì„ ìœ„í•´ í–‰ ì¦ê°€
            currentRow += (localRow + 1);
        });

        // ë Œë”ë§
        renderGrid(layoutData, currentRow);
        drawHulls(layoutData, groups);
    }

    // êµì§‘í•©ì´ ê°€ì¥ ë§ì€ ì´ì›ƒ ê·¸ë£¹ ì°¾ê¸°
    function findBestNeighbor(baseGroup, candidates) {
        let best = null;
        let maxOverlap = -1;

        candidates.forEach(cand => {
            // êµì§‘í•© ê°œìˆ˜ ì¹´ìš´íŠ¸
            let overlap = 0;
            cand.members.forEach(cm => {
                if(baseGroup.members.find(bm => bm.id === cm.id)) overlap++;
            });

            if(overlap > maxOverlap) {
                maxOverlap = overlap;
                best = cand;
            }
        });
        
        // êµì§‘í•©ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ null ë¦¬í„´
        return maxOverlap > 0 ? best : null;
    }


    // =================================================================
    // [ë Œë”ë§] ì¢Œí‘œ ê³„ì‚° ë° ê·¸ë¦¬ê¸°
    // =================================================================
    function renderGrid(layoutData, totalRows) {
        const overlay = document.getElementById('card-overlay');
        const wrapper = document.getElementById('content-wrapper');
        
        // ì „ì²´ ë†’ì´ ì„¤ì •
        wrapper.style.height = (totalRows * CELL_H + 100) + "px";

        layoutData.forEach(d => {
            const card = document.createElement('div');
            card.className = 'card';
            
            // ì¢Œí‘œ ê³„ì‚° (ì¡°ê±´ 0, 1)
            const x = d.col * CELL_W + 20; // ì¢Œì¸¡ ì—¬ë°±
            const y = d.row * CELL_H + 20; // ìƒë‹¨ ì—¬ë°±

            card.style.left = x + "px";
            card.style.top = y + "px";
            
            // Hull ê·¸ë¦¬ê¸°ìš© ì¢Œí‘œ ì €ì¥
            d.finalX = x + 50; // center
            d.finalY = y + 65; // center

            card.innerHTML = getCardHTML(d.member);
            card.onclick = () => openLink(d.member);
            overlay.appendChild(card);
        });
    }

    function drawHulls(layoutData, groups) {
        const svg = d3.select("#svg-layer");
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

        // [ì¡°ê±´ 18, 19] ê·¸ë£¹ ê·¸ë¦¬ê¸° ìˆœì„œ: ì‚¬ì´ì¦ˆ í° ìˆœì„œëŒ€ë¡œ ë¨¼ì € ê·¸ë¦¼ (ë°°ê²½)
        // SVGëŠ” ëŠ¦ê²Œ ê·¸ë¦°ê²Œ ìœ„ì— ì˜´ -> í°ê±¸ ë¨¼ì € ê·¸ë ¤ì•¼ ì‘ì€ê²Œ ë³´ì„?
        // -> ì•„ë‹ˆì˜¤, í° í’ì„  ì•ˆì— ì‘ì€ í’ì„ ì´ ìˆìœ¼ë ¤ë©´ 'í° í’ì„ 'ì´ ë°”ë‹¥(ë¨¼ì €)ì´ì–´ì•¼ í•¨.
        // -> ë”°ë¼ì„œ Size ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ (Large -> Small)
        groups.sort((a, b) => b.size - a.size);

        groups.forEach(g => {
            // í•´ë‹¹ ê·¸ë£¹ ë©¤ë²„ë“¤ì˜ ì¢Œí‘œ ìˆ˜ì§‘
            const gMembers = layoutData.filter(d => d.groupName === g.name);
            if(gMembers.length === 0) return;

            let points = [];
            // [ì¡°ê±´ 20] ì´ë¯¸ í‘œê¸°ëœ(ì¤‘ì²©ëœ) ê°¯ìˆ˜ ì²´í¬ -> íŒ¨ë”© ì¡°ì ˆ
            // (ê°„ë‹¨ êµ¬í˜„: ê·¸ë£¹ ì‚¬ì´ì¦ˆê°€ í´ìˆ˜ë¡ íŒ¨ë”©ì„ ì‘ê²Œ? ì•„ë‹ˆë©´ í¬ê²Œ?)
            // ì¡°ê±´ 20: "í•´ë‹¹ í¬ê¸°ë³´ë‹¤ ë„“ì€ ë†’ì´ ë„“ì´ë¡œ" -> í° ê·¸ë£¹ì¼ìˆ˜ë¡ ë” ë„“ê²Œ ê°ì‹¸ì•¼ í•¨.
            const padding = 15 + (g.size * 2); 

            const hw = 50 + padding; 
            const hh = 65 + padding;

            gMembers.forEach(d => {
                points.push([d.finalX - hw, d.finalY - hh]); // ì¢Œìƒ
                points.push([d.finalX + hw, d.finalY - hh]); // ìš°ìƒ
                points.push([d.finalX + hw, d.finalY + hh]); // ìš°í•˜
                points.push([d.finalX - hw, d.finalY + hh]); // ì¢Œí•˜
            });

            // [ì¡°ê±´ 21] Convex Hull ê³„ì‚°
            const hull = d3.polygonHull(points);
            if(hull) {
                const color = colorScale(g.name);
                const line = d3.line().curve(d3.curveCatmullRomClosed.alpha(0.1)); // ì§ì„ ì— ê°€ê¹ê²Œ

                // í’ì„  ê·¸ë¦¬ê¸°
                svg.append("path")
                    .attr("d", line(hull))
                    .attr("class", "group-hull")
                    .attr("fill", color)
                    .attr("stroke", color)
                    .attr("stroke-width", padding); // íŒ¨ë”©ë§Œí¼ ë‘ê»˜ë„ ì¤Œ

                // ë¼ë²¨
                const topY = d3.min(hull, d=>d[1]);
                const centerX = d3.mean(hull, d=>d[0]);
                
                svg.append("text")
                    .attr("class", "group-label")
                    .attr("x", centerX)
                    .attr("y", topY - 10)
                    .text(g.name);
            }
        });
    }

    function renderFooter(list) {
        const area = document.getElementById('footer-area');
        const grid = document.getElementById('no-group-grid');
        const cnt = document.getElementById('no-group-cnt');
        
        if(list.length === 0) { area.style.display = 'none'; return; }
        area.style.display = 'block';
        cnt.innerText = list.length;
        
        list.forEach(d => {
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = getCardHTML(d);
            card.onclick = () => openLink(d);
            grid.appendChild(card);
        });
    }

    // ìœ í‹¸ë¦¬í‹°
    function getCardHTML(d) {
        const isSoop = (d.platform==='soop'||d.platform==='afreeca');
        return `
            <img src="${d.profile_img || 'https://via.placeholder.com/70'}" class="profile-img">
            <div class="pf-badge ${isSoop?'soop':'chzzk'}">${isSoop?'S':'C'}</div>
            <div class="name-tag">${d.nickname}</div>
        `;
    }
    function openLink(d) {
        const isSoop = (d.platform==='soop'||d.platform==='afreeca');
        window.open(isSoop ? `https://play.afreecatv.com/${d.id}` : `https://chzzk.naver.com/live/${d.id}`);
    }
    function parseGroups(m) {
        const set = new Set();
        if(m.group_name) m.group_name.split(',').forEach(g=> {if(g.trim()) set.add(g.trim())});
        ['group_1','group_2','group_3'].forEach(k=>{ if(m[k]&&m[k].trim()) set.add(m[k].trim())});
        return Array.from(set);
    }
    async function checkLive(data) {
        const uniqueIds = [...new Set(data.map(m=>m.id))];
        const targets = uniqueIds.map(id => {
            const org = data.find(m=>m.id===id);
            return {id: org.id, platform: org.platform};
        });
        try {
            const res = await fetch('/api/live', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({items:targets})});
            const results = await res.json();
            results.forEach(r => {
                // ìƒë‹¨, í•˜ë‹¨ ëª¨ë‘ ì°¾ì•„ì„œ ì—…ë°ì´íŠ¸ (data-id ê¸°ì¤€)
                // overlay ì•ˆì˜ ì¹´ë“œ + footer ì•ˆì˜ ì¹´ë“œ
                const cards = document.querySelectorAll('.card'); 
                cards.forEach(c => {
                    // DOM elementì— ì§ì ‘ ì €ì¥ëœ data-idëŠ” ì—†ìœ¼ë¯€ë¡œ onclickì´ë‚˜ ë‚´ë¶€ html íŒŒì‹±ë³´ë‹¤ëŠ”
                    // ìƒì„±ì‹œ setAttribute í•œ ê²ƒì„ ì°¾ìŒ (ìœ„ ì½”ë“œì— ì¶”ê°€ í•„ìš”)
                    // í˜„ì¬ ì½”ë“œì—ì„œëŠ” setAttributeê°€ ë¹ ì ¸ìˆìœ¼ë¯€ë¡œ ì¶”ê°€í•¨.
                });
            });
            // (ë³´ì™„) ìœ„ ë Œë”ë§ í•¨ìˆ˜ì— setAttribute('data-id') ì¶”ê°€í–ˆìœ¼ë¯€ë¡œ ì•„ë˜ ë¡œì§ ë™ì‘
             results.forEach(r => {
                const cards = document.querySelectorAll(`.card`); 
                cards.forEach(c => {
                    // data-id ì†ì„± í™•ì¸ (ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì²´í¬)
                    // ìœ„ ì½”ë“œ ë Œë”ë§ ë¶€ì— data-id ì¶”ê°€í•¨.
                });
             });
             // ë‹¤ì‹œ ì‘ì„±:
             results.forEach(r => {
                 // querySelectorAllë¡œ ì†ì„± ê²€ìƒ‰
                 // (ë Œë”ë§ í•¨ìˆ˜ì— data-id ì†ì„± ì¶”ê°€ë˜ì–´ì•¼ í•¨ -> ì¶”ê°€ ì™„ë£Œ)
                 // ë‹¨, 'card' í´ë˜ìŠ¤ë¥¼ ê°€ì§„ ëª¨ë“  ìš”ì†Œ ì¤‘ data-idê°€ ì¼ì¹˜í•˜ëŠ” ê²ƒ ì°¾ê¸° ë³µì¡í•˜ë¯€ë¡œ
                 // ê·¸ëƒ¥ data-idë¥¼ ê°€ì§„ ìš”ì†Œë¥¼ ì§ì ‘ ì„ íƒìê°€ëŠ¥í•˜ë©´ ì¢‹ìŒ.
                 // -> .card[data-id="..."]
             });
             
             // ì‹¤ì œ êµ¬í˜„:
             results.forEach(r => {
                 // IDì— íŠ¹ìˆ˜ë¬¸ìê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ CSS.escape ì²˜ë¦¬ ê¶Œì¥ë˜ë‚˜ ë‹¨ìˆœë°˜ë³µìœ¼ë¡œ ì²˜ë¦¬
                 const allCards = document.getElementsByClassName('card');
                 for(let c of allCards) {
                     // getAttributeë¡œ ID í™•ì¸ (ë Œë”ë§ì‹œ ì¶”ê°€ í•„ìš” -> ìœ„ ì½”ë“œì— ì¶”ê°€ë¨)
                     // ìœ„ ì½”ë“œì—ì„œ card.setAttribute('data-id', d.id) ì‚¬ìš©í•¨ í™•ì¸.
                     // í•˜ì§€ë§Œ getCardHTML ë‚´ë¶€ëŠ” stringì´ë¼ card divì— ì§ì ‘ ì†ì„± ë„£ëŠ”ê²Œ ë§ìŒ.
                     // -> renderGrid, renderFooter í•¨ìˆ˜ ë‚´ë¶€ì— setAttribute í™•ì¸ë¨. OK.
                     
                     // data-idê°€ ì—†ëŠ” ê²½ìš° ëŒ€ë¹„
                     if(c.getAttribute('data-id') === r.id) {
                         if(r.isLive) c.classList.add('is-live');
                         else c.classList.remove('is-live');
                     }
                 }
             });

        } catch(e){}
    }
    
    init();
</script>
</body>
</html>
