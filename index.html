<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer Fixed Grid Board</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* [ê¸°ë³¸ ìŠ¤íƒ€ì¼] */
        body { margin: 0; background: #f4f6f8; font-family: 'Pretendard', sans-serif; overflow-x: hidden; }
        .container { width: 100%; min-height: 100vh; position: relative; display: flex; flex-direction: column; align-items: center; }

        .admin-link { position: fixed; top: 20px; right: 20px; font-size: 2rem; text-decoration: none; opacity: 0.5; z-index: 1000; }
        .admin-link:hover { opacity: 1; }

        /* [ìƒë‹¨: ê·¸ë£¹ í’ì„  ì˜ì—­] */
        #main-area {
            position: relative;
            width: 100%;
            height: 80vh; /* í™”ë©´ì˜ 80% ì‚¬ìš© */
            overflow: hidden; /* SVGê°€ ë„˜ì–´ê°€ì§€ ì•Šê²Œ */
        }
        
        svg { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* ì¹´ë“œë“¤ì´ ë°°ì¹˜ë  ì»¨í…Œì´ë„ˆ (ì ˆëŒ€ ì¢Œí‘œ ì‚¬ìš©) */
        #card-overlay {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 2; pointer-events: none;
        }

        /* [í•˜ë‹¨: ë¯¸ë¶„ë¥˜ ì˜ì—­] */
        #footer-area {
            width: 90%;
            max-width: 1200px;
            background: #fff;
            border-radius: 20px;
            margin: 20px 0 50px 0;
            padding: 30px;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.05);
            border: 2px dashed #ccc;
            z-index: 10;
        }
        .footer-title { font-size: 1.2rem; font-weight: bold; color: #555; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .no-group-grid { display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; }

        /* [ì¹´ë“œ ìŠ¤íƒ€ì¼] */
        .card {
            position: absolute; /* ìƒë‹¨ ì˜ì—­ì—ì„œëŠ” ì ˆëŒ€ ì¢Œí‘œ */
            width: 90px; height: 120px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            padding-top: 10px;
            box-sizing: border-box;
            border: 2px solid transparent;
            cursor: pointer;
            pointer-events: auto; 
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover { transform: translateY(-5px) scale(1.02) !important; z-index: 10; box-shadow: 0 8px 20px rgba(0,0,0,0.2); }

        /* í•˜ë‹¨ ì˜ì—­ìš© ì¹´ë“œ ìŠ¤íƒ€ì¼ ì¬ì •ì˜ (ìƒëŒ€ ì¢Œí‘œ) */
        .no-group-grid .card {
            position: relative;
            transform: none;
            left: auto !important; top: auto !important;
        }

        .profile-wrap { width: 60px; height: 60px; position: relative; margin-bottom: 8px; }
        .profile-img { width: 100%; height: 100%; border-radius: 50%; object-fit: cover; border: 2px solid #eee; }
        .pf-badge {
            position: absolute; bottom: -2px; right: -2px; width: 20px; height: 20px; border-radius: 50%;
            color: #fff; font-size: 10px; font-weight: bold; display: flex; align-items: center; justify-content: center; border: 2px solid #fff;
        }
        .soop { background: #42C769; } .chzzk { background: #00E59D; color:#333; }

        .name-tag { font-size: 0.85rem; font-weight: bold; color: #333; width: 80px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* ë¼ì´ë¸Œ íš¨ê³¼ */
        .is-live { border-color: #ff4757; background: #fff5f5; }
        .is-live .profile-img { border-color: #ff4757; animation: pulse 1.5s infinite; }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0.6); }
            70% { box-shadow: 0 0 0 8px rgba(255, 71, 87, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0); }
        }

        /* í’ì„  ìŠ¤íƒ€ì¼ */
        .group-hull {
            fill-opacity: 0.1; stroke-width: 3px; stroke-linejoin: round; stroke-linecap: round; mix-blend-mode: multiply;
        }
        .group-label {
            font-size: 15px; font-weight: 800; fill: #444; text-anchor: middle;
            text-shadow: 2px 2px 0 #fff, -1px -1px 0 #fff; pointer-events: none;
        }
    </style>
</head>
<body>

<div class="container">
    <a href="admin.html" class="admin-link">âš™ï¸</a>

    <div id="main-area">
        <svg id="svg-layer"></svg>
        <div id="card-overlay"></div>
    </div>

    <div id="footer-area" style="display:none;">
        <div class="footer-title">
            <span>ğŸ“‚ ê·¸ë£¹ ë¯¸ì§€ì • ìŠ¤íŠ¸ë¦¬ë¨¸</span>
            <span id="no-group-count" style="background:#eee; padding:2px 8px; border-radius:10px; font-size:0.8rem;">0</span>
        </div>
        <div id="no-group-grid" class="no-group-grid"></div>
    </div>
</div>

<script>
    // [ì„¤ì •ê°’]
    const CARD_W = 90; 
    const CARD_H = 120; 
    const GAP = 15; // ì¹´ë“œ ê°„ ê°„ê²©

    async function init() {
        try {
            const res = await fetch('/api/get_list');
            const data = await res.json();
            if (!data || data.length === 0) return;

            // 1. ë°ì´í„° ë¶„ë¥˜ (Grouped vs NoGroup)
            const groupedNodes = [];
            const noGroupNodes = [];

            data.forEach(m => {
                m._groups = parseGroups(m);
                if (m._groups.length === 0) {
                    noGroupNodes.push(m);
                } else {
                    groupedNodes.push(m);
                }
            });

            // 2. í•˜ë‹¨ ì˜ì—­ ë Œë”ë§ (ë¯¸ë¶„ë¥˜)
            renderNoGroup(noGroupNodes);

            // 3. ìƒë‹¨ ì˜ì—­ ê³„ì‚° ë° ë Œë”ë§ (ê·¸ë£¹)
            if (groupedNodes.length > 0) {
                calculateAndRenderGroups(groupedNodes);
            }

            // 4. ë¼ì´ë¸Œ ì²´í¬
            checkLive(data);

        } catch (e) { console.error(e); }
    }

    // [í•µì‹¬ ë¡œì§] ê·¸ë£¹ë³„ ê·¸ë¦¬ë“œ ê³„ì‚° ë° ì „ì²´ ë°°ì¹˜
    function calculateAndRenderGroups(nodes) {
        // (1) ê·¸ë£¹ë³„ë¡œ ë…¸ë“œë¥¼ ë¬¶ìŒ (ê³ ìœ  ê·¸ë£¹ í‚¤ ì‚¬ìš©)
        // í•œ ëª…ì´ ì—¬ëŸ¬ ê·¸ë£¹ì¼ ê²½ìš°: "A + B" ë¼ëŠ” ë³„ë„ ê·¸ë£¹ìœ¼ë¡œ ì·¨ê¸‰í•˜ì—¬ 'ë‹¤ë¦¬' ì—­í•  ìˆ˜í–‰
        // ë§Œì•½ A, B ë³„ë„ë¡œ ë°°ì¹˜í•˜ê³  ì‹¶ë‹¤ë©´ ë¡œì§ì´ ë‹¬ë¼ì§€ë‚˜, 
        // "ë¬¶ìŒ í’ì„ "ì„ ê¹”ë”í•˜ê²Œ ê·¸ë¦¬ë ¤ë©´ 'ì¡°í•©'ë³„ë¡œ ë­‰ì¹˜ëŠ”ê²Œ ê°€ì¥ ê¹”ë”í•¨.
        const groupMap = {};
        
        nodes.forEach(node => {
            // ê·¸ë£¹ëª… ì •ë ¬í•˜ì—¬ í‚¤ ìƒì„± (ì˜ˆ: "ì´ë§¤ë°©ë‘, ìœ ì•¤ì•„ì´")
            const groupKey = node._groups.sort().join(' + ');
            if(!groupMap[groupKey]) groupMap[groupKey] = [];
            groupMap[groupKey].push(node);
        });

        // (2) ê° ê·¸ë£¹ ë‚´ë¶€ì˜ ê·¸ë¦¬ë“œ ì¢Œí‘œ(Local) ê³„ì‚°
        const packData = []; // d3.packì— ë„£ì„ ë°ì´í„°

        Object.keys(groupMap).forEach(key => {
            const members = groupMap[key];
            const count = members.length;
            
            // ë°”ë‘‘íŒ ë°°ì—´ ê³„ì‚° (Cols x Rows)
            const cols = Math.ceil(Math.sqrt(count));
            const rows = Math.ceil(count / cols);

            const groupWidth = cols * CARD_W + (cols - 1) * GAP;
            const groupHeight = rows * CARD_H + (rows - 1) * GAP;
            
            // ê·¸ë£¹ì˜ ë°˜ì§€ë¦„(Radius) ì¶”ì • (íŒ¨í‚¹ìš©)
            // ëŒ€ê°ì„  ê¸¸ì´ì˜ ì ˆë°˜ ì •ë„ë¥¼ ë°˜ì§€ë¦„ìœ¼ë¡œ ì¡ìŒ
            const radius = Math.sqrt(groupWidth**2 + groupHeight**2) / 2 + 40; // ì—¬ìœ ê³µê°„ 40

            // ê° ë©¤ë²„ì—ê²Œ ë¡œì»¬ ì¢Œí‘œ ë¶€ì—¬ (ì¤‘ì‹¬ì  0,0 ê¸°ì¤€)
            members.forEach((m, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                // ì¢Œìƒë‹¨ ê¸°ì¤€ ì¢Œí‘œ
                const x = col * (CARD_W + GAP);
                const y = row * (CARD_H + GAP);

                // ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™ì‹œí‚¤ê¸° ìœ„í•œ ì˜¤í”„ì…‹
                m.localX = x - groupWidth / 2 + CARD_W / 2;
                m.localY = y - groupHeight / 2 + CARD_H / 2;
            });

            packData.push({
                groupName: key,
                members: members,
                r: radius // d3.packì´ ì´ ê°’ì„ ë³´ê³  ì›ë“¤ì„ ë°°ì¹˜í•¨
            });
        });

        // (3) ê·¸ë£¹ ê°„ ì „ì—­ ë°°ì¹˜ (Global Layout) - Circle Packing ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
        // ë¬¼ë¦¬ì—”ì§„ ì•„ë‹˜. ìˆ˜í•™ì ìœ¼ë¡œ ê²¹ì¹˜ì§€ ì•Šê²Œ ì›ì„ ë°°ì¹˜í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.
        const packLayout = d3.pack()
            .size([window.innerWidth, window.innerHeight * 0.8])
            .padding(20);

        const root = d3.hierarchy({ children: packData })
            .sum(d => d.r); // ë°˜ì§€ë¦„ ê¸°ì¤€ ê°€ì¤‘ì¹˜

        const packed = packLayout(root).leaves(); // ë°°ì¹˜ ì™„ë£Œëœ ë…¸ë“œë“¤

        // (4) ìµœì¢… ë Œë”ë§
        const svg = d3.select("#svg-layer");
        const overlay = d3.select("#card-overlay");
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

        packed.forEach(node => {
            const groupInfo = node.data; // packDataì˜ í•­ëª©
            const groupX = node.x;       // ê³„ì‚°ëœ ê·¸ë£¹ ì¤‘ì‹¬ X
            const groupY = node.y;       // ê³„ì‚°ëœ ê·¸ë£¹ ì¤‘ì‹¬ Y

            // -- 4-1. ë©¤ë²„ë“¤ ë°°ì¹˜ (Div Card) --
            // ë©¤ë²„ë“¤ì˜ localX, localYì— groupX, groupYë¥¼ ë”í•´ ì ˆëŒ€ ìœ„ì¹˜ í™•ì •
            const groupMembers = groupInfo.members;
            
            // í—(Hull) ê³„ì‚°ì„ ìœ„í•œ í¬ì¸íŠ¸ ìˆ˜ì§‘
            let hullPoints = [];

            groupMembers.forEach(m => {
                const finalX = groupX + m.localX;
                const finalY = groupY + m.localY;
                
                // HTML ì¹´ë“œ ìƒì„± ë° ë°°ì¹˜
                overlay.append("div")
                    .attr("class", "card")
                    .attr("data-id", m.id) // ë¼ì´ë¸Œ ì²´í¬ìš©
                    .style("left", `${finalX}px`)
                    .style("top", `${finalY}px`)
                    .style("transform", "translate(-50%, -50%)") // ì¤‘ì‹¬ì  ê¸°ì¤€ ì •ë ¬
                    .html(getCardHTML(m))
                    .on("click", () => window.open(getLink(m)));

                // Hull í¬ì¸íŠ¸ ì¶”ê°€ (ì¹´ë“œ ë„¤ ëª¨ì„œë¦¬)
                // ì¹´ë“œë³´ë‹¤ ì¡°ê¸ˆ ë” ë„“ê²Œ(padding) ì¡ì•„ì„œ í’ì„ ì´ ë„‰ë„‰í•˜ê²Œ ê°ì‹¸ë„ë¡ í•¨
                const p = 15; // padding
                const w = CARD_W/2 + p;
                const h = CARD_H/2 + p;
                hullPoints.push([finalX - w, finalY - h]);
                hullPoints.push([finalX + w, finalY - h]);
                hullPoints.push([finalX + w, finalY + h]);
                hullPoints.push([finalX - w, finalY + h]);
            });

            // -- 4-2. í’ì„  ê·¸ë¦¬ê¸° (SVG Hull) --
            if(hullPoints.length > 0) {
                const hull = d3.polygonHull(hullPoints);
                if(hull) {
                    const color = colorScale(groupInfo.groupName);
                    const lineGen = d3.line().curve(d3.curveCatmullRomClosed.alpha(0.5)); // ë¶€ë“œëŸ¬ìš´ ê³¡ì„ 

                    svg.append("path")
                        .attr("d", lineGen(hull))
                        .attr("class", "group-hull")
                        .attr("fill", color)
                        .attr("stroke", color);

                    // ê·¸ë£¹ ë¼ë²¨
                    const topPoint = d3.min(hull, d => d[1]);
                    const centerPointX = d3.mean(hull, d => d[0]);
                    
                    svg.append("text")
                        .attr("class", "group-label")
                        .attr("x", centerPointX)
                        .attr("y", topPoint - 10)
                        .text(groupInfo.groupName);
                }
            }
        });
    }

    // [í•˜ë‹¨] ë¯¸ë¶„ë¥˜ ë Œë”ë§
    function renderNoGroup(list) {
        const area = document.getElementById('footer-area');
        const grid = document.getElementById('no-group-grid');
        const count = document.getElementById('no-group-count');

        if(list.length === 0) { area.style.display = 'none'; return; }
        
        area.style.display = 'block';
        count.innerText = list.length;
        
        list.forEach(m => {
            const card = document.createElement('div');
            card.className = 'card';
            card.setAttribute('data-id', m.id);
            card.innerHTML = getCardHTML(m);
            card.onclick = () => window.open(getLink(m));
            grid.appendChild(card);
        });
    }

    // [ìœ í‹¸] ì¹´ë“œ HTML
    function getCardHTML(m) {
        const pf = m.platform || 'soop';
        const isSoop = pf === 'soop' || pf === 'afreeca';
        return `
            <div class="profile-wrap">
                <img src="${m.profile_img || 'https://via.placeholder.com/60'}" class="profile-img">
                <div class="pf-badge ${isSoop?'soop':'chzzk'}">${isSoop?'S':'C'}</div>
            </div>
            <div class="name-tag">${m.nickname || m.id}</div>
        `;
    }

    // [ìœ í‹¸] ë§í¬ ìƒì„±
    function getLink(m) {
        const pf = m.platform || 'soop';
        return (pf === 'soop' || pf === 'afreeca') 
            ? `https://play.afreecatv.com/${m.id}` 
            : `https://chzzk.naver.com/live/${m.id}`;
    }

    // [ìœ í‹¸] ê·¸ë£¹ íŒŒì‹±
    function parseGroups(m) {
        const set = new Set();
        if(m.group_name) m.group_name.split(',').forEach(g=> { if(g.trim()) set.add(g.trim()) });
        ['group_1','group_2','group_3'].forEach(k => { if(m[k] && m[k].trim()) set.add(m[k].trim()) });
        return Array.from(set);
    }

    // [ìœ í‹¸] ë¼ì´ë¸Œ ì²´í¬
    async function checkLive(allMembers) {
        const uniqueIds = [...new Set(allMembers.map(m => m.id))];
        const targets = uniqueIds.map(id => {
            const origin = allMembers.find(m => m.id === id);
            return { id: origin.id, platform: origin.platform };
        });

        try {
            const res = await fetch('/api/live', {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ items: targets })
            });
            const results = await res.json();
            
            // ëª¨ë“  ì¹´ë“œ(ìƒë‹¨+í•˜ë‹¨) ìƒíƒœ ì—…ë°ì´íŠ¸
            results.forEach(r => {
                const cards = document.querySelectorAll(`.card[data-id="${r.id}"]`);
                cards.forEach(card => {
                    if(r.isLive) card.classList.add('is-live');
                    else card.classList.remove('is-live');
                });
            });
        } catch(e) { console.error(e); }
    }

    init();
</script>
</body>
</html>
